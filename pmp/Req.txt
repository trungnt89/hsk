https://script.google.com/macros/s/AKfycbz-CilJVS0UgOFRHtgF8fhaGA7IM8sNE4vOZYkvZugKp6XlyesS058QeFJbTZ4ZTA_q/exec?key=current_state

git add . ;  git commit -m "SRC change" ; git push;



üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥
NGHI√äM C·∫§M m·ªçi h√†nh vi s·ª≠a code ngo√†i ph·∫°m vi y√™u c·∫ßu , s·ª≠ d·ª•ng git diff ƒë·ªÉ check cho t√¥i xem v√† ph√™ duy·ªát
ch·ªâ th·ª±c hi·ªán y√™u c·∫ßu d∆∞·ªõi ƒë√¢y, n·∫øu b·∫°n s·ª≠a src ngo√†i ph·∫°m vi y√™u c·∫ßu t√¥i s·∫Ω ki·ªán b·∫°n. 
Sau khi ƒë·ªëi ·ª©ng c√°c y√™u c·∫ßu h√£y t·∫°o file ƒë√£ s·ª≠a ho√†n ch·ªânh
üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥üî≥
1. B·ªï sung log ƒë·∫ßy ƒë·ªß l√Ω do g·ª≠i/kh√¥ng g·ª≠i notify v√† s·ªë l·∫ßn ƒë√£ g·ª≠i
-------------------
Src g·ªëc c·∫ßn s·ª≠a:
-------------------
/* ==================================================================================================
Y√äU C·∫¶U H·ªÜ TH·ªêNG:
1. ƒê·ªçc sheet chuy·ªÉn th√†nh json, s·ª≠ d·ª•ng header ƒë·ªông, ko fix c·ª©ng ƒë·ªÉ c√≥ th·ªÉ th√™m c·ªôt t√πy √Ω
2. ƒê·ªçc json ·ªü b∆∞·ªõc 1 ƒë·ªÉ ti·∫øn h√†nh g·ª≠i notify ,c·∫≠p nh·∫≠t l·∫°i LastNotified,AlertCount trong json sau ƒë√≥ ghi ƒë√® json v√†o sheet
3. Nh·∫≠n reply t·ª´ user, update v√†o c·ªôt ng√†y t∆∞∆°ng ·ª©ng . N·∫øu ng√†y ch∆∞a c√≥ th√¨ b·ªï sung v√†o json ·ªü b∆∞·ªõc 1, 
   s·∫Øp x·∫øp ng√†y tƒÉng d·∫ßn sau ƒë√≥ ghi ƒë√® v√†o sheet
4. T·∫§T C·∫¢ C√ÅC B∆Ø·ªöC X·ª¨ L√ù ƒê·ªÄU PH·∫¢I C√ì LOG chi ti·∫øt c·ª• th·ªÉ, ƒë·∫∑c bi·ªát vi·ªác g·ª≠i v√† nh·∫≠n notify
==================================================================================================
*/

/* ==================================================================================================
Y√äU C·∫¶U H·ªÜ TH·ªêNG:
1. ƒê·ªçc sheet chuy·ªÉn th√†nh json, s·ª≠ d·ª•ng header ƒë·ªông, ko fix c·ª©ng ƒë·ªÉ c√≥ th·ªÉ th√™m c·ªôt t√πy √Ω
2. ƒê·ªçc json ·ªü b∆∞·ªõc 1 ƒë·ªÉ ti·∫øn h√†nh g·ª≠i notify ,c·∫≠p nh·∫≠t l·∫°i LastNotified,AlertCount trong json sau ƒë√≥ ghi ƒë√® json v√†o sheet
3. Nh·∫≠n reply t·ª´ user, update v√†o c·ªôt ng√†y t∆∞∆°ng ·ª©ng . N·∫øu ng√†y ch∆∞a c√≥ th√¨ b·ªï sung v√†o json ·ªü b∆∞·ªõc 1, 
   s·∫Øp x·∫øp ng√†y tƒÉng d·∫ßn sau ƒë√≥ ghi ƒë√® v√†o sheet
4. T·∫§T C·∫¢ C√ÅC B∆Ø·ªöC X·ª¨ L√ù ƒê·ªÄU PH·∫¢I C√ì LOG chi ti·∫øt c·ª• th·ªÉ, ƒë·∫∑c bi·ªát vi·ªác g·ª≠i v√† nh·∫≠n notify
==================================================================================================
*/

const TELEGRAM_TOKEN = "8019068142:AAEyOi2cg-TBIr-XPfkHP4iqMw_rj9XLw1s";
const SHEET_ID = "1ezoFMSBVznSNcuufRRQRjxAmUmYyU9MjKDzl-v3wxl8";
const SHEET_NAME = "Tasks";
/**
 * L·∫•y ti√™u ƒë·ªÅ th√¥ t·ª´ Sheet ƒë·ªÉ ph·ª•c v·ª• ƒë·ªìng b·ªô
 */
function getRawHeadersFromSheet() {
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME);
  return sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
}

/**
 * 1. CHUY·ªÇN SHEET TH√ÄNH JSON (HEADER ƒê·ªòNG)
 */
function getSheetAsJson() {
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME);
  const data = sheet.getDataRange().getValues();
  const rawHeaders = data[0];
  writeLog("JSON_PROCESS", `ƒê·ªçc Sheet. C·∫•u tr√∫c Header ƒë·ªông detected: ${rawHeaders.length} c·ªôt.`);
  
  const json = data.slice(1).map((row) => {
    let obj = {};
    rawHeaders.forEach((h, i) => {
      let key = (h instanceof Date) ? Utilities.formatDate(h, "GMT+9", "dd/MM") : String(h);
      obj[key] = row[i];
    });
    return obj;
  });
  
  writeLog("JSON_SUCCESS", `Convert th√†nh c√¥ng ${json.length} d√≤ng d·ªØ li·ªáu.`);
  return { json: json, rawHeaders: rawHeaders };
}

/**
 * 2. G·ª¨I NOTIFY D·ª∞A TR√äN JSON (C·∫¨P NH·∫¨T QUA JSON)
 */
function sendTaskNotifications() {
  writeLog("NOTIFY_START", "--- B·∫Øt ƒë·∫ßu qu√©t Notify ---");
  const { json, rawHeaders } = getSheetAsJson();
  const now = new Date();
  const todayStr = Utilities.formatDate(now, "GMT+9", "dd/MM");
  const currentTimeNum = now.getHours() * 60 + now.getMinutes();
  let hasChange = false;
console.log(json);
  json.forEach((task) => {
    const taskId = task["Key"];
    const status = String(task["Status"]);
    const userId = String(task["UserID"]).trim();
    const startStr = String(task["Start"]);
    const freq = Number(task["Freg"] || 30);
    const lastNotified = task["LastNotified"];
    const todayResult = String(task[todayStr] || "").toLowerCase();

    if (status !== "1") {
      writeLog("NOTIFY_SKIP", `Key ${taskId}: Status off.`);
      return;
    }
    if (userId === "") {
      writeLog("NOTIFY_SKIP", `Key ${taskId}: Tr·ªëng UserID.`);
      return;
    }

    if (!todayResult.includes("done")) {
      try {
        const [h, m] = startStr.split(":").map(Number);
        const startMinutes = h * 60 + m;

        if (currentTimeNum >= startMinutes) {
          let shouldNotify = false;
          let reason = "";

          if (!lastNotified || lastNotified === "") {
            shouldNotify = true;
            reason = "G·ª≠i l·∫ßn ƒë·∫ßu";
          } else {
            const lastDate = new Date(lastNotified);
            const diffMin = Math.floor((now - lastDate) / (1000 * 60));
            if (diffMin >= freq) {
              shouldNotify = true;
              reason = `Qu√° h·∫°n Freg (${diffMin}p >= ${freq}p)`;
            } else {
              writeLog("NOTIFY_SKIP", `Key ${taskId}: Gi√£n c√°ch ch∆∞a ƒë·ªß (${diffMin}/${freq}p).`);
            }
          }

          if (shouldNotify) {
            sendTelegram(userId, `üîî *NH·∫ÆC NH·ªû*\nüìù ${task["TaskContent"]}\n\nüëâ *Reply* ƒë·ªÉ update.\n\`[ID:${taskId}]\``);
            
            // C·∫¨P NH·∫¨T TR·ª∞C TI·∫æP V√ÄO JSON
            task["LastNotified"] = now;
            task["AlertCount"] = (Number(task["AlertCount"]) || 0) + 1;
            hasChange = true;
            writeLog("NOTIFY_SENT", `Key ${taskId}: ${reason}. AlertCount: ${task["AlertCount"]}`);
          }
        } else {
          writeLog("NOTIFY_SKIP", `Key ${taskId}: Ch∆∞a t·ªõi gi·ªù (${currentTimeNum} < ${startMinutes}).`);
        }
      } catch (err) {
        writeLog("NOTIFY_ERROR", `L·ªói Key ${taskId}: ${err.message}`);
      }
    } else {
      writeLog("NOTIFY_SKIP", `Key ${taskId}: ƒê√£ done.`);
    }
  });

  if (hasChange) {
    syncJsonToSheet(json, rawHeaders);
  }
  writeLog("NOTIFY_END", "--- K·∫øt th√∫c qu√©t Notify ---");
}

/**
 * 3. NH·∫¨N REPLY & C·∫¨P NH·∫¨T JSON (S·∫ÆP X·∫æP NG√ÄY)
 */
function doPost(e) {
  try {
    const update = JSON.parse(e.postData.contents);
    writeLog("WEBHOOK_RECEIVE", "Nh·∫≠n d·ªØ li·ªáu Telegram.");

    if (!update.message || !update.message.reply_to_message) return;

    const replyText = update.message.text;
    const originalText = update.message.reply_to_message.text;
    const idMatch = originalText.match(/\[ID:(\d+)\]/);
    
    if (idMatch) {
      writeLog("REPLY_DETECT", `Ph√°t hi·ªán ID ${idMatch[1]}. ƒêang update JSON...`);
      updateSheetByTaskId(idMatch[1], replyText);
      sendTelegram(update.message.chat.id, `‚úÖ ƒê√£ ghi nh·∫≠n ID ${idMatch[1]}.`);
    }
  } catch (err) {
    writeLog("CRITICAL_ERROR", `L·ªói doPost: ${err.toString()}`);
  }
}

function updateSheetByTaskId(taskId, content) {
  const { json, rawHeaders } = getSheetAsJson();
  const now = new Date();
  const todayStr = Utilities.formatDate(now, "GMT+9", "dd/MM");
  const timeStr = Utilities.formatDate(now, "GMT+9", "HH:mm");

  const datePattern = /^\d{1,2}\/\d{1,2}$/;
  let dateHeaders = [];
  json.forEach(t => {
    Object.keys(t).forEach(k => {
      if (datePattern.test(k) && !dateHeaders.includes(k)) dateHeaders.push(k);
    });
  });

  if (!dateHeaders.includes(todayStr)) {
    dateHeaders.push(todayStr);
    json.forEach(t => { if (!(todayStr in t)) t[todayStr] = ""; });
    writeLog("HEADER_NEW", `Th√™m ng√†y m·ªõi ${todayStr} v√†o JSON.`);
  }

  let found = false;
  json.forEach(task => {
    if (String(task["Key"]) === String(taskId)) {
      const entry = `[${timeStr}] ${content}`;
      task[todayStr] = task[todayStr] ? task[todayStr] + "\n" + entry : entry;
      found = true;
      writeLog("DATA_UPDATE", `C·∫≠p nh·∫≠t n·ªôi dung cho Key ${taskId} v√†o JSON.`);
    }
  });

  if (found) {
    syncJsonToSheet(json, rawHeaders);
  } else {
    writeLog("SYNC_FAIL", `Kh√¥ng t√¨m th·∫•y Key ${taskId}.`);
  }
}

/**
 * H√ÄM ƒê·ªíNG B·ªò: S·∫ÆP X·∫æP V√Ä GHI ƒê√à SHEET
 */
function syncJsonToSheet(json, rawHeaders) {
  writeLog("SYNC_START", "ƒêang ghi ƒë√® JSON v√†o Sheet...");
  const datePattern = /^\d{1,2}\/\d{1,2}$/;
  const attrHeaders = rawHeaders.map(h => (h instanceof Date) ? Utilities.formatDate(h, "GMT+9", "dd/MM") : String(h)).filter(h => !datePattern.test(h));
  
  let dateHeaders = [];
  json.forEach(t => {
    Object.keys(t).forEach(k => {
      if (datePattern.test(k) && !dateHeaders.includes(k)) dateHeaders.push(k);
    });
  });

  dateHeaders.sort((a, b) => {
    const p = (s) => { const [d, m] = s.split('/').map(Number); return new Date(2026, m - 1, d); };
    return p(a) - p(b);
  });

  const finalHeaders = [...attrHeaders, ...dateHeaders];
  const outputData = [finalHeaders];
  json.forEach(t => outputData.push(finalHeaders.map(h => t[h] || "")));

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME);
  sheet.clearContents();
  sheet.getRange(1, 1, outputData.length, finalHeaders.length).setValues(outputData);
  writeLog("SYNC_COMPLETE", `Ghi ƒë√® th√†nh c√¥ng.`);
}

/**
 * 4. H√ÄM GHI LOG
 */
function writeLog(type, content) {
  Logger.log(type + ":" + content);
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    let logSheet = ss.getSheetByName("Logs") || ss.insertSheet("Logs");
    logSheet.insertRowAfter(1);
    logSheet.getRange(2, 1, 1, 3).setValues([[new Date(), type, content]]);
  } catch (e) {}
}

function sendTelegram(chatId, text) {
  const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
  UrlFetchApp.fetch(url, {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify({ chat_id: chatId, text: text, parse_mode: "Markdown" })
  });
}